package main

import (
	"fmt"
	"sync"
)

func main() {
	if err := send(); err != nil {
		fmt.Printf("err %v", err)
	}
}

const concurrency = 3

func send() error {
	// ctx, cancel := context.WithCancel(context.Background())
	// defer cancel()

	lines := []int{1, 2, 3, 4, 5, 6, 7}
	for l := range lines {
		fmt.Println(l)
	}

	sem := make(chan struct{}, concurrency)
	errs := make(chan error, 1)
	var wg sync.WaitGroup
	for l := range lines {
		select {
		case sem <- struct{}{}:
		}
		wg.Add(1)
		go func(n int) {
			defer wg.Done()
			defer func() { <-sem }()
			if err := fnA(n); err != nil {
				errs <- fmt.Errorf("failed to A, %v", err)
				return
			}

			if err := fnB(n); err != nil {
				errs <- fmt.Errorf("failed to B, %v", err)
				return
			}
		}(l)
	}

	go func() {
		wg.Wait()
		close(sem)
		close(errs)
	}()
	if err, ok := <-errs; ok {
		return err
	}
	return nil
}

func fnA(n int) error {
	return fmt.Errorf("error A %d", n)
}
func fnB(n int) error {
	return fmt.Errorf("error B %d", n)
}
